---
alwaysApply: false
---
# AgenticCP Business Exception 개발 규칙

## 🎯 Business Exception 개발 원칙

### 1. 예외 처리 구조 준수
- 모든 비즈니스 예외는 `BusinessException` 계층구조를 따름
- 도메인별 `ErrorCode` enum으로 명확한 에러 분류
- `BaseErrorCode` 인터페이스 구현 필수
- `GlobalExceptionHandler`에서 자동으로 `ApiResponse` 변환

### 2. 도메인별 에러 코드 카테고리 관리
```java
// ErrorCategory 사용법
public enum ErrorCategory {
    COMMON("COMMON_"),      // 0000-0999 (HTTP 상태 코드 그대로)
    AUTH("AUTH_"),          // 1000-1999
    USER("USER_"),          // 2000-2999
    TENANT("TENANT_"),      // 3000-3999
    CLOUD("CLOUD_"),        // 4000-4999
    SECURITY("SECURITY_"),  // 5000-5999
    PLATFORM("PLATFORM_"),  // 6000-6999
    COST("COST_"),          // 7000-7999
    MONITORING("MONITORING_"), // 8000-8999
    INTEGRATION("INTEGRATION_"); // 9000-9999
}
```

### 3. 예외 사용 시점

#### BusinessException - 비즈니스 로직 예외
```java
// ✅ 사용 시점
- 비즈니스 로직에서 예측 가능한 예외 상황
- 사용자 입력이나 비즈니스 규칙 위반 시
- 개발자 실수나 시스템 장애가 아닌 경우

// 예시
if (isNicknameDuplicate(dto.getNickname())) {
    throw new BusinessException(UserErrorCode.DUPLICATE_NICKNAME);
}
```

#### ResourceNotFoundException - 데이터 없음 (404)
```java
// ✅ 사용 시점
- 데이터베이스 조회 결과가 없을 때
- NPE 대신 명확한 "데이터 없음" 상황 표현

// 예시
return userRepository.findById(userId)
    .orElseThrow(() -> new ResourceNotFoundException(UserErrorCode.USER_NOT_FOUND));
```

#### AuthorizationException - 권한 없음 (403)
```java
// ✅ 사용 시점
- 인증은 되었지만 특정 리소스에 대한 권한이 없을 때
- 역할 기반 접근 제어에서 권한 확인 실패 시

// 생성자 종류
new AuthorizationException()                                    // 기본
new AuthorizationException(userId, "Post", "delete")           // 리소스별 권한
new AuthorizationException(userId, "ADMIN")                    // 역할 기반 권한
new AuthorizationException(userId)                              // 사용자별 권한
```

### 4. ErrorCode 구현 규칙

#### BaseErrorCode 인터페이스 구현
```java
public interface BaseErrorCode {
    HttpStatus getHttpStatus();  // HTTP 상태 코드
    String getCode();           // 에러 코드 (예: "USER_1001")
    String getMessage();        // 에러 메시지
}
```

#### 도메인별 ErrorCode Enum 생성
```java
public enum UserErrorCode implements BaseErrorCode {
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, 2001, "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL(HttpStatus.CONFLICT, 2002, "이미 사용 중인 이메일입니다."),
    INVALID_USER_STATUS(HttpStatus.BAD_REQUEST, 2003, "유효하지 않은 사용자 상태입니다.");
    
    @Override
    public String getCode() {
        return ErrorCategory.USER.generate(codeNumber); // "USER_2001"
    }
}
```

### 5. 에러 코드 번호 범위 관리
```java
// ✅ 도메인별 범위 준수
USER_NOT_FOUND(2001)        // USER 도메인 범위 (2000-2999)
TENANT_QUOTA_EXCEEDED(3002) // TENANT 도메인 범위 (3000-3999)
CLOUD_SERVICE_ERROR(4001)   // CLOUD 도메인 범위 (4000-4999)

// ❌ 범위 초과 금지
USER_NOT_FOUND(5001)        // USER 도메인 범위를 벗어남
TENANT_ERROR(2001)          // TENANT 도메인이지만 USER 범위 사용
```

### 6. ApiResponse 응답 형식

#### 성공 응답
```java
// 데이터만 포함
ApiResponse.success(userData)

// 메시지와 함께
ApiResponse.success(userData, "사용자 정보를 성공적으로 조회했습니다.")
```

#### 에러 응답
```java
// 단순 에러
ApiResponse.error(UserErrorCode.USER_NOT_FOUND)

// 커스텀 메시지와 함께
ApiResponse.error(UserErrorCode.DUPLICATE_EMAIL, "이미 사용 중인 이메일입니다.")
```

### 7. 새로운 도메인 예외 추가 시 체크리스트

1. **ErrorCategory에 새 카테고리 추가** (번호 범위와 함께)
2. **도메인별 ErrorCode Enum 생성** (해당 범위 내에서)
3. **BaseErrorCode 인터페이스 구현**
4. **필요시 커스텀 예외 클래스 생성** (선택사항)
5. **에러 코드 번호가 할당된 범위 내에 있는지 확인**

### 8. 금지사항

- ❌ 도메인 범위를 벗어난 에러 코드 번호 사용
- ❌ 시스템 오류에 BusinessException 사용 (CommonErrorCode 사용)
- ❌ NPE 대신 ResourceNotFoundException 사용하지 않기
- ❌ 권한 확인 없이 AuthorizationException 사용하지 않기
- ❌ 일관성 없는 예외 처리 (모든 예외는 BusinessException 계층구조 준수)

### 9. 권장사항

- ✅ 예외 메시지는 사용자 친화적으로 작성
- ✅ 에러 코드는 도메인별로 명확하게 분류
- ✅ HTTP 상태 코드와 비즈니스 에러 코드를 적절히 매핑
- ✅ GlobalExceptionHandler에서 자동 처리되도록 구조화
- ✅ 테스트에서 예외 상황도 함께 검증

## 📝 개발 시 체크리스트

1. **예외 타입 선택**: BusinessException vs ResourceNotFoundException vs AuthorizationException
2. **ErrorCode 범위 확인**: 해당 도메인의 번호 범위 내에서 사용
3. **HTTP 상태 코드 매핑**: 적절한 HTTP 상태 코드 설정
4. **메시지 작성**: 사용자 친화적이고 명확한 에러 메시지
5. **테스트 작성**: 예외 상황에 대한 테스트 케이스 포함
# AgenticCP Business Exception 개발 규칙

## 🎯 Business Exception 개발 원칙

### 1. 예외 처리 구조 준수
- 모든 비즈니스 예외는 `BusinessException` 계층구조를 따름
- 도메인별 `ErrorCode` enum으로 명확한 에러 분류
- `BaseErrorCode` 인터페이스 구현 필수
- `GlobalExceptionHandler`에서 자동으로 `ApiResponse` 변환

### 2. 도메인별 에러 코드 카테고리 관리
```java
// ErrorCategory 사용법
public enum ErrorCategory {
    COMMON("COMMON_"),      // 0000-0999 (HTTP 상태 코드 그대로)
    AUTH("AUTH_"),          // 1000-1999
    USER("USER_"),          // 2000-2999
    TENANT("TENANT_"),      // 3000-3999
    CLOUD("CLOUD_"),        // 4000-4999
    SECURITY("SECURITY_"),  // 5000-5999
    PLATFORM("PLATFORM_"),  // 6000-6999
    COST("COST_"),          // 7000-7999
    MONITORING("MONITORING_"), // 8000-8999
    INTEGRATION("INTEGRATION_"); // 9000-9999
}
```

### 3. 예외 사용 시점

#### BusinessException - 비즈니스 로직 예외
```java
// ✅ 사용 시점
- 비즈니스 로직에서 예측 가능한 예외 상황
- 사용자 입력이나 비즈니스 규칙 위반 시
- 개발자 실수나 시스템 장애가 아닌 경우

// 예시
if (isNicknameDuplicate(dto.getNickname())) {
    throw new BusinessException(UserErrorCode.DUPLICATE_NICKNAME);
}
```

#### ResourceNotFoundException - 데이터 없음 (404)
```java
// ✅ 사용 시점
- 데이터베이스 조회 결과가 없을 때
- NPE 대신 명확한 "데이터 없음" 상황 표현

// 예시
return userRepository.findById(userId)
    .orElseThrow(() -> new ResourceNotFoundException(UserErrorCode.USER_NOT_FOUND));
```

#### AuthorizationException - 권한 없음 (403)
```java
// ✅ 사용 시점
- 인증은 되었지만 특정 리소스에 대한 권한이 없을 때
- 역할 기반 접근 제어에서 권한 확인 실패 시

// 생성자 종류
new AuthorizationException()                                    // 기본
new AuthorizationException(userId, "Post", "delete")           // 리소스별 권한
new AuthorizationException(userId, "ADMIN")                    // 역할 기반 권한
new AuthorizationException(userId)                              // 사용자별 권한
```

### 4. ErrorCode 구현 규칙

#### BaseErrorCode 인터페이스 구현
```java
public interface BaseErrorCode {
    HttpStatus getHttpStatus();  // HTTP 상태 코드
    String getCode();           // 에러 코드 (예: "USER_1001")
    String getMessage();        // 에러 메시지
}
```

#### 도메인별 ErrorCode Enum 생성
```java
public enum UserErrorCode implements BaseErrorCode {
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, 2001, "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL(HttpStatus.CONFLICT, 2002, "이미 사용 중인 이메일입니다."),
    INVALID_USER_STATUS(HttpStatus.BAD_REQUEST, 2003, "유효하지 않은 사용자 상태입니다.");
    
    @Override
    public String getCode() {
        return ErrorCategory.USER.generate(codeNumber); // "USER_2001"
    }
}
```

### 5. 에러 코드 번호 범위 관리
```java
// ✅ 도메인별 범위 준수
USER_NOT_FOUND(2001)        // USER 도메인 범위 (2000-2999)
TENANT_QUOTA_EXCEEDED(3002) // TENANT 도메인 범위 (3000-3999)
CLOUD_SERVICE_ERROR(4001)   // CLOUD 도메인 범위 (4000-4999)

// ❌ 범위 초과 금지
USER_NOT_FOUND(5001)        // USER 도메인 범위를 벗어남
TENANT_ERROR(2001)          // TENANT 도메인이지만 USER 범위 사용
```

### 6. ApiResponse 응답 형식

#### 성공 응답
```java
// 데이터만 포함
ApiResponse.success(userData)

// 메시지와 함께
ApiResponse.success(userData, "사용자 정보를 성공적으로 조회했습니다.")
```

#### 에러 응답
```java
// 단순 에러
ApiResponse.error(UserErrorCode.USER_NOT_FOUND)

// 커스텀 메시지와 함께
ApiResponse.error(UserErrorCode.DUPLICATE_EMAIL, "이미 사용 중인 이메일입니다.")
```

### 7. 새로운 도메인 예외 추가 시 체크리스트

1. **ErrorCategory에 새 카테고리 추가** (번호 범위와 함께)
2. **도메인별 ErrorCode Enum 생성** (해당 범위 내에서)
3. **BaseErrorCode 인터페이스 구현**
4. **필요시 커스텀 예외 클래스 생성** (선택사항)
5. **에러 코드 번호가 할당된 범위 내에 있는지 확인**

### 8. 금지사항

- ❌ 도메인 범위를 벗어난 에러 코드 번호 사용
- ❌ 시스템 오류에 BusinessException 사용 (CommonErrorCode 사용)
- ❌ NPE 대신 ResourceNotFoundException 사용하지 않기
- ❌ 권한 확인 없이 AuthorizationException 사용하지 않기
- ❌ 일관성 없는 예외 처리 (모든 예외는 BusinessException 계층구조 준수)

### 9. 권장사항

- ✅ 예외 메시지는 사용자 친화적으로 작성
- ✅ 에러 코드는 도메인별로 명확하게 분류
- ✅ HTTP 상태 코드와 비즈니스 에러 코드를 적절히 매핑
- ✅ GlobalExceptionHandler에서 자동 처리되도록 구조화
- ✅ 테스트에서 예외 상황도 함께 검증

## 📝 개발 시 체크리스트

1. **예외 타입 선택**: BusinessException vs ResourceNotFoundException vs AuthorizationException
2. **ErrorCode 범위 확인**: 해당 도메인의 번호 범위 내에서 사용
3. **HTTP 상태 코드 매핑**: 적절한 HTTP 상태 코드 설정
4. **메시지 작성**: 사용자 친화적이고 명확한 에러 메시지
5. **테스트 작성**: 예외 상황에 대한 테스트 케이스 포함
